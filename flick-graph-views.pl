#!/usr/bin/perl
use strict;
## http://linuxgazette.net/issue83/padala.html
## http://www.ibm.com/developerworks/library/os-perlgdchart/
use GD::Graph::lines;
use Getopt::Long;
use Storable;
use POSIX; # floor
#
# Generate line graph of total views/photos viewed for individual pages
#
# usage: perl flick-graph-views.pl
#
# The base file ($log_file, see below) is generated by another script (cf. flick-store-views.pl at
# cf. http://gnu.univ.gda.pl/~tomasz/prog/perl/scripts/flickr/scripts/)
#
# (c) T.Przechlewski 11/2007 (tprzechlewski@acm.org)
# One can distribute/modify the file under the terms of the GNU General Public License.
#
# See also companion scripts: flick-store-views.pl and flick-report-views.pl
# cf. http://gnu.univ.gda.pl/~tomasz/prog/perl/scripts/flickr/scripts/
#
my ($download_date, $status, $photo, $views, $url, $raw_file) ;

my %PhotoLog;
my $debug = 0; ## change to 0 to supress debug
my $flickr_user = "hr.icio" ;
my $fdir = "http://www.flickr.com/photos/tprzechlewski/"; #
my $log_file = "flick-views.log" ;
my $img_file = "flick-views.png" ;
my $html_log = "flick-views-log.phtml" ;

my $LL = "------------------------------------------------\n" ;

## all info is collected, now read the log file, update, and write updated
## information back to disc file:

if (-f "$log_file") { my $PhotoLogRef ;
   $PhotoLogRef = retrieve("$log_file") || die " *** ERROR: unable to retrieve from $log_file *** ";
   %PhotoLog = %{ $PhotoLogRef } ; 
   if ($debug ) { print " >> $log_file OK!\n"; }
} else { %PhotoLog = () ; }


my @tmp = keys %PhotoLog; if ( $#tmp < 1) { warn "Insufficient data to draw graph!"; exit 0;  }
print_daily_counts(\%PhotoLog);

## ///////////////////////
## Iterate over whole data:
sub print_daily_counts {

  my $PhotoLogRf = shift ; # reference to hash
  
  my ($date, $id, $today_views, $viewed_photos, $yesterday_views, $last_viewed_photos );
  my ($new_viewed_photos, $new_viewed_views, $max_viewed, $max_photos);
  my $yesterday = '';

  my @Views = ();
  my @VP = ();
  my @Dates = ();
  my $first_row_style = "style='font-weight : bold'";
  my $default_row_style = '';

  open ( HTML, ">$html_log") || die " *** Problems writing to $html_log *** ";

  my $Today = d2s( (reverse keys %{$PhotoLogRf})[0] );

  print "------ Date: #Views: #Photos:   V/P:   ##TV: ---\n$LL" ;

  print HTML "<p>Detailed figures concerning number of viewed photos and total number of
     views from my <a href='$fdir'>flickr photo album</a>. V/P denotes mean (views/photos),
     while ##TV denotes total number of views. Note: first row (printed bold) contains cumulative data registered at $Today.</p>";
  print HTML "<div>\n";
  print HTML "<table style='text-align: right; margin-left: auto; margin-right: auto;' border='1' cellpadding='3' ><tr><td>Date </td><td> #Views </td><td> #Photos </td><td> V/P </td><td> ##TV </td></tr>\n" ;
  for $date (sort keys %{$PhotoLogRf} ) {

    $today_views = $viewed_photos = $new_viewed_photos = 0;
    my @tmp = keys %{$PhotoLog{$date}} ; my $total_photos_no = $#tmp + 1; 
    ### warn  ">>>>> $total_photos_no";

    for $id ( keys %{$PhotoLog{$date}} ) {

       $today_views += ${$PhotoLog{$date}}{$id};

       if ( exists ${$PhotoLog{$yesterday}}{$id} ) {
          if ( ${$PhotoLog{$date}}{$id} > ${$PhotoLog{$yesterday}}{$id} ) {  $new_viewed_photos++ }
       }
       else {
         if ( ${$PhotoLog{$date}}{$id} > 0) {  $new_viewed_photos++ }
       }

       if ( ${$PhotoLog{$date}}{$id} > 0 ) { $viewed_photos++ ; }

    }

    $new_viewed_views = $yesterday eq '' ?  $today_views : $today_views - $yesterday_views;

    printf "%s: %6d %8d %6.2f %7d\n", $date,
           $new_viewed_views, $new_viewed_photos,
           $new_viewed_photos > 0 ? ($today_views - $yesterday_views) / $new_viewed_photos : 0,
           $today_views, $viewed_photos;
           ##$yesterday eq '' ? $viewed_photos  : $viewed_photos - $last_viewed_photos;
    printf HTML "<tr %s><td> %s </td><td> %d </td><td> %d </td><td> %.2f </td><td> %d</td></tr>\n",
           $yesterday eq '' ? $first_row_style : $default_row_style,
           d2s($date),
           $yesterday eq '' ?  $today_views : $today_views - $yesterday_views,
           $new_viewed_photos,
           $new_viewed_photos > 0 ? ($today_views - $yesterday_views) / $new_viewed_photos : 0,
           $today_views, $viewed_photos;

    if ( $yesterday ne "" )  { 
        my $short_date = substr($date, 2, 6);
        ###print ">>>>>>>>> $short_date\n";
        push ( @Views, $today_views - $yesterday_views );
        push ( @VP, $new_viewed_photos );
        push ( @Dates, $short_date);
    }

    if ( $yesterday eq '' ) {print $LL; } # table head ends here

    unless ( $yesterday eq '' ) {# skip first row
      if ($new_viewed_views > $max_viewed ) { $max_viewed = $new_viewed_views } ;
      if ($new_viewed_photos > $max_photos ) { $max_photos = $new_viewed_photos };
    }

    $last_viewed_photos = $viewed_photos  ;

    $yesterday_views = $today_views ;

    $yesterday = $date ;

  }

  print "$LL";
  print HTML "</table>\n</div>\n";
  print HTML "<div>Max views: $max_viewed, max viewed photos: $max_photos.</div>\n";

  close(HTML);

  my @data = (\@Dates, \@Views, \@VP, );

  my $mygraph = GD::Graph::lines->new(400, 300);

#  If the option "x_tick_number" is set to a defined value, GD::Graph will attempt to
#  treat the X data as numerical.
#  If set to 'auto', GD::Graph will attempt to format the X axis in a nice way, 
#  based on the actual X values. 
#  If set to a number, that's the number of ticks you will get. [[but treated as numbers, tp.]]
#  If set to undef, GD::Graph will treat X data as labels. Default: undef.
#  [[Auto is of no use as well, tp.]
#
#  x_label_skip, y_label_skip
#  Print every x_label_skipth number under the tick on the x axis, and every 
#  y_label_skipth number next to the
#  tick on the y axis.  Default: 1 for both.
#

# skip some dates to avoid label overlapping on X-axis:
  my $x_factor = floor (($#Dates + 1) / 10 ) + 2;
  print "$#Dates observations. X-axis labels printed evey ${x_factor}th one!\n";

  $mygraph->set_text_clr('black');
  $mygraph->set(
    x_label     => 'Time',
    y_label     => '#',
    title       => "# of Photos/Photo Views for $flickr_user",
    # Draw datasets in 'solid', 'dashed' and 'dotted-dashed' lines
    line_types  => [1, 1, ],
    # Set the thickness of line
    line_width  => 2,
    # Set colors for datasets
    dclrs       => ['blue', 'red', 'cyan'],
    #x_tick_number => 'auto',
    x_label_skip => $x_factor,
    transparent => 0, ## non-transparent
    bgclr => 'white',
    fgclr => 'black',
    borderclrs => 'black',
    boxclr => '#ede7e7',
    labelclr => 'black',
    #axislabelclr,
    legendclr => 'black',
  ) or warn $mygraph->error;

  $mygraph->set_legend_font(GD::gdMediumBoldFont);
  $mygraph->set_legend('views', 'photos', '???');

  my $myimage = $mygraph->plot(\@data) or die $mygraph->error;

  ## for cgi script uncomment:
  ##print "Content-type: image/png\n\n";

  open ( IMG, ">$img_file") or die " *** Problems opening: $img_file ***" ;

  print IMG $myimage->png;

  close (IMG);

}

## eof ##

sub d2s {# return formatted date:
  my $s = shift;
  return ( substr($s,0,4)  . substr($s,4,2) .  substr($s,6,2)	 . 
	   "T" . substr($s,8,2) . ":" . substr($s,10,2));
}
